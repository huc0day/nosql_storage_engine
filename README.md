# nosql_storage_engine
C language project (NOSQL storage engine)

hash_manager.h

这是一个C语言实现的哈希表头文件，定义了两种哈希表结构：

    UniqueEntry表特点：

    使用开放寻址法处理冲突
    键类型为char*，值类型为int
    表大小为1048577(2^20+1，选择质数减少冲突)
    支持惰性删除(is_deleted标记)

    IndexEntry表特点：

    使用链地址法处理冲突
    键类型为uint64_t，值类型为void*
    每个桶使用链表存储冲突元素

提供的接口包括：

    两种键类型的哈希计算函数
    插入/查询/删除操作
    两种表结构各自的操作函数

这个头文件设计合理，考虑了：

    冲突处理(开放寻址法和链地址法)
    惰性删除优化
    通用数据存储(void*)
    错误处理(KEY_NOT_FOUND)
    大质数表大小选择

需要配合对应的.c实现文件使用（hash_manager.c），实现这些接口的具体功能。

hash_manager.c

这是一个C语言实现的哈希表C源文件,代码实现了一个高效的哈希表系统，包含两种不同的哈希表实现方式：

    ‌唯一索引哈希表(UniqueEntry表)‌：

    使用开放寻址法处理冲突，采用线性探测策略
    实现了惰性删除机制(is_deleted标记位)
    使用DJB2哈希算法(初始值5381，乘数33)计算字符串键的哈希值
    提供完整的CRUD操作接口(insert/query/delete)

    ‌普通索引哈希表(IndexEntry表)‌：

    使用链地址法处理冲突
    直接对uint64_t键取模作为哈希值
    采用头插法维护链表结构
    支持任意数据类型存储(void*指针)

代码中的几个关键实现细节：

    哈希表大小TABLE_SIZE选择为质数(1048577)，减少哈希冲突
    字符串键使用strdup分配内存，确保键值独立性
    删除操作正确处理了内存释放问题
    使用do-while循环确保完整遍历整个哈希表

技术总结：该实现综合了两种主流的哈希冲突解决方法，适用于不同场景需求。开放寻址法实现更节省内存，而链地址法实现更易于处理动态数据。代码结构清晰，错误处理完善，是一个高质量的哈希表实现。


unique_manager.h

这是一个唯一键值管理器的头文件实现，采用Trie树(前缀树)数据结构来高效管理字符串键。以下是关键设计分析：

    ‌数据结构设计‌：

    unique_key_node结构体构成Trie树节点，支持37个子节点(a-z0-9+_字符集)
    unique_index作为树根容器，维护节点计数和根指针
    每个节点存储字符(key_char)、层级(level)和行ID(row_id)

    ‌核心功能接口‌：

    init_unique_manager：初始化空索引树3
    insert_unique_key：插入键值对(时间复杂度O(L)，L为键长)
    search_unique_key：精确查找键对应的行ID
    delete_unique_key：惰性删除节点(标记而非立即释放)
    free_unique_manager：递归释放整棵树内存

    ‌工程特性‌：

    使用标准C头文件保护宏防止重复包含
    严格的函数原型声明，参数和返回值类型明确
    注释清晰标注各结构体和函数用途
    设计为无状态模块，通过指针参数操作数据结构

技术总结：该实现特别适合代理服务器需要快速路由查找的场景，Trie树结构对字符串前缀匹配有天然优势。size_t类型的使用确保能处理大容量键值存储。

unique_manager.c

这是一个基于Trie树(字典树)实现的唯一键值管理器，主要用于高效存储和检索字符串键与数值的映射关系。以下是代码的核心实现分析：

    ‌数据结构设计‌：

    使用37叉树结构(a-z0-9+_)存储键字符
    每个节点包含字符标记(key_char)和关联的行ID(row_id)
    通过level字段记录节点深度

    ‌核心算法实现‌：

    字符转换：_char_to_index将字符映射到0-36的数组下标
    递归插入：_insert_recursive实现深度优先的键插入
    惰性删除：_delete_recursive仅清除row_id标记
    内存回收：删除时自动释放无子节点的分支

    ‌标准库使用‌：

    使用calloc进行节点内存分配和清零初始化
    通过free实现递归内存释放
    依赖stdio.h进行测试输出

技术总结：该实现特别适合需要快速前缀匹配的场景，如代理服务器的路由表管理。相比哈希表方案，Trie树在以下方面具有优势：

    天然支持前缀搜索
    无哈希冲突问题
    键有序存储

(未完待续)
